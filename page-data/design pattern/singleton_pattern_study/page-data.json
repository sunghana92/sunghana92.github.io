{"componentChunkName":"component---src-templates-blog-post-js","path":"/design pattern/singleton_pattern_study/","result":{"data":{"site":{"siteMetadata":{"title":"Bee starter","author":"[Your Name]","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"b8ecf057-80a9-571a-8b2b-8e9af6b69bf9","excerpt":"싱글톤 패턴 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴. 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.(자바에선 생성자를 private로 선언해서 생성 불가하게 하고 getInstance…","html":"<p><strong>싱글톤 패턴</strong></p>\n<p>애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴.</p>\n<p>생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.<strong>(자바에선 생성자를 private로 선언해서 생성 불가하게 하고 getInstance()로 받아쓰기도 함) => 인스턴스가 필요할 때 인스턴스를 만들지 않고 기존의 인스턴스를 사용하게함.</strong></p>\n<p><strong>싱글톤 패턴을 쓰는 이유</strong></p>\n<p>고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있음. 또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스들의 인스턴스들이 공유하기 쉽니다.</p>\n<p>DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용하는 상황에서 많이 사용한다.</p>\n<p>안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편하기 때문에 사용한다.</p>\n<p>인스턴스가 절대적으로 한개만 존재하는것을 보증하고 싶을 때 사용.</p>\n<p>두번째 이용시부터는 객체 로딩시간이 현저하게 줄어 성능이 좋아지는 장점이있다.</p>\n<p><strong>싱글톤 패턴의 문제점</strong></p>\n<p>싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 “개방-폐쇄 원칙”을 위배하게 된다.(객체지향 설계원칙에 어긋난다.)</p>\n<p>멀티쓰레드환경에서 동기화 처리를 안하면 인스턴스가 2개가 생성되는 문제가 발생 할 수 있다.( 해결은 ? =><strong>동기화(Synchronized)</strong>를 해서 하나의 인스턴스만 존재하게 해야한다.)</p>\n<p>&#x3C;결론> 싱글톤 패턴의 문제점은?</p>\n<ol>\n<li>멀티스레드 환경에서 동기화 처리를 안 하면 인스턴스가 여러개가 생성되는 문제가 발생할 수 있다.</li>\n<li>\n<p>싱글톤 객체가 많으면 객체지향 설계 원칙에 어긋난다.</p>\n<ul>\n<li>외부에서 주입받는게 아니라 new 키워드를 사용해서 스스로 생성하고 있다.(DIP)</li>\n<li>여러 곳에서 사용될 경우 다른 클래스간의 결합도가 높아진다.(OCP)</li>\n</ul>\n</li>\n</ol>\n<p><strong>싱글톤 패턴의 구현 방법</strong></p>\n<ol>\n<li>\n<p>Thread safe Lazy initialization (게으른 초기화)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span> <span class=\"token punctuation\">{</span>\n\n   <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span> instance<span class=\"token punctuation\">;</span>\n\n   <span class=\"token keyword\">private</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>private static으로 인스턴스 변수를 만들고 private 생성자로 외부에서 생성을 막았으며 synchronized 키워드를 사용해서 thread-safe하게 만들었다.</p>\n</li>\n<li>\n<p>Thread safe Lazy initialization + Double-checked locking</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span> <span class=\"token punctuation\">{</span>\n\n   <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span> instance<span class=\"token punctuation\">;</span>\n\n   <span class=\"token keyword\">private</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ThreadSafeLazyInitialization</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n               <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span>\n                   instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadSafeLazyInitialization</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token punctuation\">}</span>\n       <span class=\"token punctuation\">}</span>\n       <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>getInstance()에 synchronized를 사용하는 것이 아니라 첫번째 if문으로 인스턴스의 존재 여부를 확인후 다시한번 체크할 때 동기화 시켜서 인스턴스를 생성하므로 thread-safe하면서도 처음 생성 이후에 synchronized블럭을 타지 않기 때문에 성능저하를 완화했다.</p>\n</li>\n<li>\n<p>Initialization on demand holder idiom (holder 에 의한 초기화)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonClazz</span> <span class=\"token punctuation\">{</span>\n\n   <span class=\"token keyword\">private</span> <span class=\"token class-name\">SingletonClazz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n   <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">InstanceHolder</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">SingletonClazz</span> INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonClazz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">SingletonClazz</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">return</span> <span class=\"token class-name\">InstanceHolder</span><span class=\"token punctuation\">.</span>INSTANCE<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>개발자가 직접 동기화 문제에 대해 코드를 작성하고 문제를 회피하려 한다면 그만큼 프로그램의 구조가 복잡해지고 비용문제가 생길 수 있고 정확하지 못한 경우가 많다. 이 방법은 <strong>jvm의 클래스 초기화 과정에서 보장되는 원자적 특성을 이용하여 싱글톤의 초기화의 책임을 jvm에 떠넘긴다.</strong></p>\n<p>holder안에 선언된 instance가 static이기 때문에 클래스 로딩 시점에 한번만 호출될 것이며 final을 통해 값이 재할당되지 않도록 만든방법</p>\n<p>*가장 많이 사용하고 일반적인 singleton 클래스 사용방법이다.</p>\n</li>\n<li>Spring singleton bean 객체\n스프링에서는 @bean 어노테이션을 사용하면 스프링 컨테이너에서 그 클래스에대해서 하나의 인스턴스만 생성한다. (설정에따라서 조금씩 다를 수 있다.)</li>\n</ol>","frontmatter":{"title":"Singleton pattern","date":"February 13, 2022"}}},"pageContext":{"slug":"/design pattern/singleton_pattern_study/","previous":{"fields":{"slug":"/design pattern/observer_pattern_study/"},"frontmatter":{"title":"Observer pattern"}},"next":{"fields":{"slug":"/design pattern/Facade_pattern_study/"},"frontmatter":{"title":"Facade pattern"}}}},"staticQueryHashes":["2486386679","3128451518"]}